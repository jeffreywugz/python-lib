#!/usr/bin/python2

import os, os.path
import sys
my_fsh_dir = os.path.dirname(os.path.abspath(__file__))
import re
import json
import traceback
import exceptions
import subprocess
import mimetypes
from cgi import parse_qs
from urllib import quote
from wsgiref.simple_server import make_server

class GErr(exceptions.Exception):
    def __init__(self, msg, obj=None):
        exceptions.Exception(self)
        self.obj, self.msg = obj, msg

    def __str__(self):
        return "%s\n%s"%(self.msg, self.obj)

    def __repr__(self):
        return 'GErr(%s, %s)'%(repr(self.msg), repr(self.obj))

def id(): return 'pyRpc-0.0'

def popen(cmd, path=None):
    p = subprocess.Popen(cmd, cwd=path, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    p.wait()
    err = p.stderr.read()
    out = p.stdout.read()
    if p.returncode != 0 or err:
        raise GErr('%s\n%s'%(err, out), cmd)
    return out
    
def get(path):
    try:
        with open(path, 'r') as f:
            return f.read()
    except exceptions.IOError,e:
        print e
        return ''
    
def set(path, content):
    with open(path, 'w') as f:
        f.write(content.encode('utf-8'))

def psh(func, args, kw):
    result, tb = None, None
    try:
        result = eval(func)(*args, **kw)
    except exceptions.Exception,e:
        result, tb = str(e), traceback.format_exc()
    return [result, tb]

def get_mime_type(path):
    return mimetypes.guess_type(path)[0] or 'text/plain'

def get_query(env):
    try:
      size = int(env.get('CONTENT_LENGTH', 0))
    except exceptions.ValueError:
      size = 0
    q = dict(parse_qs(env['wsgi.input'].read(size)), **parse_qs(env['QUERY_STRING']))
    return dict((k, v[0]) for k,v in q.items())
    
def listdir(path):
    files = [(i,os.path.join(path, i)) for i in ['..']+sorted(os.listdir(path))]
    files = [(name, path, ['', '/'][os.path.isdir(path)]) for name, path in files]
    files = [(name+slash, path+slash) for name,path,slash in files]
    files = ['<li><a href="%s"><pre>%s</pre></a>'%(quote(path), name) for name, path in files]
    return '<style type="text/css">pre{margin-top:0; margin-bottom:0;} pre:hover{background-color: red;}</style><ul>%s</ul>' % '\n'.join(files)

def serve_file(path):
    content = get(path)
    if content: return get_mime_type(path), get(path)

def try_these(handlers, *args):
    for f in handlers:
        ret = f(*args)
        if ret: return ret

def err_handler(*args):
    return 'text/plain', 'Not Found!'

def index_handler(path, query):
    return serve_file(os.path.join(path, 'index.html'))

def dir_handler(path, query):
    if os.path.isdir(path): return 'text/html', listdir(path)

def file_handler(path, query):
    return serve_file(path)

def psh_handler(path, query):
    if path != '/psh': return None
    def qget(key, default): return json.loads(query.get(key, default))
    func, args, kw = qget('func', '"id"'), qget('args', '[]'), qget('kw', '{}')
    return 'text/plain', json.dumps(psh(func, args, kw))

def fsh_handler(path, query):
    match = re.search('/fsh/([^/]*)$', path)
    if not match: return None
    fsh = os.path.join(my_fsh_dir, match.group(1) or 'fsh.html')
    return serve_file(fsh)
    
def app(env, response):
    handlers = [psh_handler, fsh_handler, index_handler, dir_handler, file_handler, err_handler]
    mime, content = try_these(handlers, env.get('PATH_INFO'), get_query(env))
    response('200 OK', [('Content-Type', mime)])
    return content

def start_server(app, port=8000):
    httpd = make_server('', port, app)
    httpd.serve_forever()

if __name__ == '__main__':
    port= len(sys.argv) == 2 and int(sys.argv[1]) or 8000
    print "listening on port: ", port
    start_server(app, port)
